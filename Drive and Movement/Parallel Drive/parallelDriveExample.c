#pragma config(Motor,  port2,           lfd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           lbd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rfd,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rbd,           tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "parallelDrive.c"

#define numLeftMotors 2
#define numRightMotors 2

#include "coreIncludes.c"

typedef enum encoderConfig { NONE, LEFT, RIGHT, AVERAGE };

typedef union {
	struct {
		bool isRamped; //whether drive is ramped
		int msPerPowerChange; //if ramping, time between motor power changes, calculated using maxAcc100ms
		int deadband; //range of motor values around 0 for which motors are not engaged
		float powMap; //degree of polynomial to which inputs are mapped (1 for linear)
		float powerCoeff; //factor by which motor speeds are multiplied
		TVexJoysticks leftInput; //id of remote channel used to calculate power of left side of drive (usually Ch3)
		TVexJoysticks rightInput; //id of remote channel used to calculate power of right side of drive (usually Ch2)
		//internal variables for ramping
		long lastUpdatedLeft;
		long lastUpdatedRight;
		//associated sensors
		encoderConfig encoderConfig;
		bool hasGyro, hasEncoderL, hasEncoderR;
		tSensors gyro, leftEncoder, rightEncoder;
	};

	//motor ports used for drive
	tMotor rightMotors[numRightMotors];
	tMotor leftMotors[numLeftMotors];
} parallel_drive;


void initializeDrive(parallel_drive &drive, tMotor *leftMotorsPtr, tMotor *rightMotorsPtr, bool isRamped=false, int maxAcc100ms=20, int deadband=10, float powMap=1, float powerCoeff=1, TVexJoysticks leftInput=Ch3, TVexJoysticks rightInput=Ch2) {
	//initialize drive variables
	drive.isRamped = isRamped;
	drive.msPerPowerChange = 100 / maxAcc100ms;
	drive.deadband = deadband;
	drive.powMap = powMap;
	drive.powerCoeff = powerCoeff;
	drive.leftInput = leftInput;
	drive.rightInput = rightInput;
	drive.lastUpdatedLeft = nPgmTime;
	drive.lastUpdatedRight = nPgmTime;

	//arrays are stupid in robotc so I have to do this
	for (int i=0; i<numLeftMotors; i++) { //copy motors into drive.leftMotors
		drive.leftMotors[i] = *(leftMotorsPtr + i); //TODO: multipy i by the size of a tMotor (could be resolved by passing motor arrays as tMotor &motorArray?)
	}

	for (int i=0; i<numRightMotors; i++) { //copy motors into drive.rightMotors
		drive.rightMotors[i] = *(rightMotorsPtr + i);
	}
}


//sensor setup region
void updateEncoderConfig(parallel_drive &drive) {
	if (drive.hasEncoderL) {
		if (drive.hasEncoderR) {
			drive.encoderConfig = AVERAGE;
		} else {
			drive.encoderConfig = LEFT;
		}
	} else {
		drive.encoderConfig = RIGHT; //safe assuming nothig but attachEncoder functions call this
	}
}

void attachEncoderL(parallel_drive &drive, tSensors encoder) {
	drive.leftEncoder = encoder;
	drive.hasEncoderL = true;
	updateEncoderConfig(drive);
}

void attachEncoderR(parallel_drive &drive, tSensors encoder) {
	drive.rightEncoder = encoder;
	drive.hasEncoderR = true;
	updateEncoderConfig(drive);
}


void attachGyro(parallel_drive &drive, tSensors gyro) {
	drive.gyro = gyro;
	drive.hasGyro = true;
}

void setEncoderConfig(parallel_drive &drive, encoderConfig config) {
	drive.encoderConfig = config;
}
//end sensor setup region


//sensor access region
int encoderVal(parallel_drive &drive) {
	if (drive.encoderConfig==AVERAGE && drive.hasEncoderL && drive.hasEncoderR) {
		return (SensorValue[drive.leftEncoder] + SensorValue[drive.rightEncoder]) / 2;
	} else if (drive.encoderConfig==LEFT && drive.hasEncoderL) {
		return SensorValue[drive.leftEncoder];
	} else if (drive.encoderConfig==RIGHT && drive.hasEncoderR) {
		return SensorValue[drive.rightEncoder];
	}

	return 0;
}

int encoderVal_L(parallel_drive &drive) {
	if (drive.hasEncoderL) {
		return SensorValue[drive.leftEncoder];
	} else {
		return 0;
	}
}

int encoderVal_R(parallel_drive &drive) {
	if (drive.hasEncoderR) {
		return SensorValue[drive.rightEncoder];
	} else {
		return 0;
	}
}

void clearLeft(parallel_drive &drive) {
	if (drive.hasEncoderL) {
		SensorValue[drive.leftEncoder] = 0;
	}
}

void clearRight(parallel_drive &drive) {
	if (drive.hasEncoderR) {
		SensorValue[drive.rightEncoder] = 0;
	}
}

void clearEncoders(parallel_drive &drive) {
	clearLeft(drive);
	clearRight(drive);
}

int gyroVal(parallel_drive &drive) {
	if (drive.hasGyro) {
		return SensorValue[drive.gyro];
	} else {
		return 0;
	}
}

void clearGyro(parallel_drive &drive) {
	if (drive.hasGyro) {
		SensorValue[drive.gyro] = 0;
	}
}
//end sensor access region


//set drive power region
void setLeftPower (parallel_drive &drive, int power) {
	for (int i=0; i<numLeftMotors; i++) {
		motor[ drive.leftMotors[i] ] = power;
	}
}

void setRightPower (parallel_drive &drive, int power) {
	for (int i=0; i<numRightMotors; i++) {
		motor[ drive.rightMotors[i] ] = power;
	}
}

void setDrivePower (parallel_drive &drive, int left, int right) {
	setLeftPower(drive, left);
	setRightPower(drive, right);
}
//end set drive power region


void setDriveSide(parallel_drive &drive, bool leftSide) {
	int drivePower = 127 * drive.powerCoeff * power(vexRT[leftSide ? drive.leftInput : drive.rightInput]/127, drive.powMap); //adjust input using powMap and powerCoeff

	if (abs(drivePower) < drive.deadband) drivePower = 0;

	//handle ramping
	if (drive.isRamped) {
		long *lastUpdatePtr = (leftSide ? &drive.lastUpdatedLeft : &drive.lastUpdatedRight);
		long now = nPgmTime;
		int elapsed = now - *lastUpdatePtr;
		int currentPower = motor[ leftSide ? drive.leftMotors[0] : drive.rightMotors[0] ];

		if (elapsed > drive.msPerPowerChange) {
			int maxDiff = elapsed / drive.msPerPowerChange;

			if (abs(currentPower - drivePower) < maxDiff) {
				*lastUpdatePtr = now;
			} else {
				drivePower = (drivePower>currentPower ? currentPower+maxDiff : currentPower-maxDiff);
				*lastUpdatePtr = now - (elapsed % drive.msPerPowerChange);
			}
		}
	}

	//set drive motor power
	if (leftSide) {
		setLeftPower(drive, drivePower);
	} else {
		setRightPower(drive, drivePower);
	}
}

void driveRuntime(parallel_drive &drive) {
	setDriveSide(drive, true);
	setDriveSide(drive, false);
}

parallel_drive drive;

task main() {
	tMotor leftMotors[2] = {lfd, lbd};
	tMotor rightMotors[2] = {rfd, rbd};
	initializeDrive(drive, &(leftMotors[0]), &(rightMotors[0]));

	while (true) driveRuntime(drive);
}
